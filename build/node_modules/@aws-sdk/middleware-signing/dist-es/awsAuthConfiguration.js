"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
var _propertyProvider = require("@smithy/property-provider");
var _signatureV = require("@smithy/signature-v4");
var _utilMiddleware = require("@smithy/util-middleware");
const CREDENTIAL_EXPIRE_WINDOW = 300000;
const resolveAwsAuthConfig = input => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
  const {
    signingEscapePath = true,
    systemClockOffset = input.systemClockOffset || 0,
    sha256
  } = input;
  let signer;
  if (input.signer) {
    signer = (0, _utilMiddleware.normalizeProvider)(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => (0, _utilMiddleware.normalizeProvider)(input.region)().then(async region => [(await input.regionInfoProvider(region, {
      useFipsEndpoint: await input.useFipsEndpoint(),
      useDualstackEndpoint: await input.useDualstackEndpoint()
    })) || {}, region]).then(([regionInfo, region]) => {
      const {
        signingRegion,
        signingService
      } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || _signatureV.SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer = async authScheme => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await (0, _utilMiddleware.normalizeProvider)(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || _signatureV.SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
const resolveSigV4AuthConfig = input => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
  const {
    signingEscapePath = true,
    systemClockOffset = input.systemClockOffset || 0,
    sha256
  } = input;
  let signer;
  if (input.signer) {
    signer = (0, _utilMiddleware.normalizeProvider)(input.signer);
  } else {
    signer = (0, _utilMiddleware.normalizeProvider)(new _signatureV.SignatureV4({
      credentials: normalizedCreds,
      region: input.region,
      service: input.signingName,
      sha256,
      uriEscapePath: signingEscapePath
    }));
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
const normalizeCredentialProvider = credentials => {
  if (typeof credentials === "function") {
    return (0, _propertyProvider.memoize)(credentials, credentials => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, credentials => credentials.expiration !== undefined);
  }
  return (0, _utilMiddleware.normalizeProvider)(credentials);
};