"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromSso = void 0;
var _propertyProvider = require("@smithy/property-provider");
var _sharedIniFileLoader = require("@smithy/shared-ini-file-loader");
var _constants = require("./constants");
var _getNewSsoOidcToken = require("./getNewSsoOidcToken");
var _validateTokenExpiry = require("./validateTokenExpiry");
var _validateTokenKey = require("./validateTokenKey");
var _writeSSOTokenToFile = require("./writeSSOTokenToFile");
const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {}) => async () => {
  const profiles = await (0, _sharedIniFileLoader.parseKnownFiles)(init);
  const profileName = (0, _sharedIniFileLoader.getProfileName)(init);
  const profile = profiles[profileName];
  if (!profile) {
    throw new _propertyProvider.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new _propertyProvider.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await (0, _sharedIniFileLoader.loadSsoSessionData)(init);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new _propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new _propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await (0, _sharedIniFileLoader.getSSOTokenFromFile)(ssoSessionName);
  } catch (e) {
    throw new _propertyProvider.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${_constants.REFRESH_MESSAGE}`, false);
  }
  (0, _validateTokenKey.validateTokenKey)("accessToken", ssoToken.accessToken);
  (0, _validateTokenKey.validateTokenKey)("expiresAt", ssoToken.expiresAt);
  const {
    accessToken,
    expiresAt
  } = ssoToken;
  const existingToken = {
    token: accessToken,
    expiration: new Date(expiresAt)
  };
  if (existingToken.expiration.getTime() - Date.now() > _constants.EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
    (0, _validateTokenExpiry.validateTokenExpiry)(existingToken);
    return existingToken;
  }
  (0, _validateTokenKey.validateTokenKey)("clientId", ssoToken.clientId, true);
  (0, _validateTokenKey.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
  (0, _validateTokenKey.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await (0, _getNewSsoOidcToken.getNewSsoOidcToken)(ssoToken, ssoRegion);
    (0, _validateTokenKey.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
    (0, _validateTokenKey.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
    try {
      await (0, _writeSSOTokenToFile.writeSSOTokenToFile)(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {}
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    (0, _validateTokenExpiry.validateTokenExpiry)(existingToken);
    return existingToken;
  }
};
exports.fromSso = fromSso;