"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromTemporaryCredentials = void 0;
var _clientSts = require("@aws-sdk/client-sts");
var _propertyProvider = require("@smithy/property-provider");
const fromTemporaryCredentials = options => {
  let stsClient;
  return async () => {
    const params = {
      ...options.params,
      RoleSessionName: options.params.RoleSessionName ?? "aws-sdk-js-" + Date.now()
    };
    if (params !== null && params !== void 0 && params.SerialNumber) {
      if (!options.mfaCodeProvider) {
        throw new _propertyProvider.CredentialsProviderError(`Temporary credential requires multi-factor authentication,` + ` but no MFA code callback was provided.`, false);
      }
      params.TokenCode = await options.mfaCodeProvider(params === null || params === void 0 ? void 0 : params.SerialNumber);
    }
    if (!stsClient) stsClient = new _clientSts.STSClient({
      ...options.clientConfig,
      credentials: options.masterCredentials
    });
    if (options.clientPlugins) {
      for (const plugin of options.clientPlugins) {
        stsClient.middlewareStack.use(plugin);
      }
    }
    const {
      Credentials
    } = await stsClient.send(new _clientSts.AssumeRoleCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new _propertyProvider.CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
exports.fromTemporaryCredentials = fromTemporaryCredentials;