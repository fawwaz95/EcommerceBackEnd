"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveSSOCredentials = void 0;
var _clientSso = require("@aws-sdk/client-sso");
var _tokenProviders = require("@aws-sdk/token-providers");
var _propertyProvider = require("@smithy/property-provider");
var _sharedIniFileLoader = require("@smithy/shared-ini-file-loader");
const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({
  ssoStartUrl,
  ssoSession,
  ssoAccountId,
  ssoRegion,
  ssoRoleName,
  ssoClient,
  profile
}) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await (0, _tokenProviders.fromSso)({
        profile
      })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e) {
      throw new _propertyProvider.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  } else {
    try {
      token = await (0, _sharedIniFileLoader.getSSOTokenFromFile)(ssoStartUrl);
    } catch (e) {
      throw new _propertyProvider.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
    throw new _propertyProvider.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const {
    accessToken
  } = token;
  const sso = ssoClient || new _clientSso.SSOClient({
    region: ssoRegion
  });
  let ssoResp;
  try {
    ssoResp = await sso.send(new _clientSso.GetRoleCredentialsCommand({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e) {
    throw _propertyProvider.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const {
    roleCredentials: {
      accessKeyId,
      secretAccessKey,
      sessionToken,
      expiration
    } = {}
  } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new _propertyProvider.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  return {
    accessKeyId,
    secretAccessKey,
    sessionToken,
    expiration: new Date(expiration)
  };
};
exports.resolveSSOCredentials = resolveSSOCredentials;