"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.se_LogoutCommand = exports.se_ListAccountsCommand = exports.se_ListAccountRolesCommand = exports.se_GetRoleCredentialsCommand = exports.de_LogoutCommand = exports.de_ListAccountsCommand = exports.de_ListAccountRolesCommand = exports.de_GetRoleCredentialsCommand = void 0;
var _protocolHttp = require("@smithy/protocol-http");
var _smithyClient = require("@smithy/smithy-client");
var _models_ = require("../models/models_0");
var _SSOServiceException = require("../models/SSOServiceException");
const se_GetRoleCredentialsCommand = async (input, context) => {
  const {
    hostname,
    protocol = "https",
    port,
    path: basePath
  } = await context.endpoint();
  const headers = (0, _smithyClient.map)({}, isSerializableHeaderValue, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath !== null && basePath !== void 0 && basePath.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
  const query = (0, _smithyClient.map)({
    role_name: [, (0, _smithyClient.expectNonNull)(input.roleName, `roleName`)],
    account_id: [, (0, _smithyClient.expectNonNull)(input.accountId, `accountId`)]
  });
  let body;
  return new _protocolHttp.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};
exports.se_GetRoleCredentialsCommand = se_GetRoleCredentialsCommand;
const se_ListAccountRolesCommand = async (input, context) => {
  const {
    hostname,
    protocol = "https",
    port,
    path: basePath
  } = await context.endpoint();
  const headers = (0, _smithyClient.map)({}, isSerializableHeaderValue, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath !== null && basePath !== void 0 && basePath.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
  const query = (0, _smithyClient.map)({
    next_token: [, input.nextToken],
    max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    account_id: [, (0, _smithyClient.expectNonNull)(input.accountId, `accountId`)]
  });
  let body;
  return new _protocolHttp.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};
exports.se_ListAccountRolesCommand = se_ListAccountRolesCommand;
const se_ListAccountsCommand = async (input, context) => {
  const {
    hostname,
    protocol = "https",
    port,
    path: basePath
  } = await context.endpoint();
  const headers = (0, _smithyClient.map)({}, isSerializableHeaderValue, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath !== null && basePath !== void 0 && basePath.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
  const query = (0, _smithyClient.map)({
    next_token: [, input.nextToken],
    max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()]
  });
  let body;
  return new _protocolHttp.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};
exports.se_ListAccountsCommand = se_ListAccountsCommand;
const se_LogoutCommand = async (input, context) => {
  const {
    hostname,
    protocol = "https",
    port,
    path: basePath
  } = await context.endpoint();
  const headers = (0, _smithyClient.map)({}, isSerializableHeaderValue, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath !== null && basePath !== void 0 && basePath.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
  let body;
  return new _protocolHttp.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};
exports.se_LogoutCommand = se_LogoutCommand;
const de_GetRoleCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_GetRoleCredentialsCommandError(output, context);
  }
  const contents = (0, _smithyClient.map)({
    $metadata: deserializeMetadata(output)
  });
  const data = (0, _smithyClient.expectNonNull)((0, _smithyClient.expectObject)(await parseBody(output.body, context)), "body");
  const doc = (0, _smithyClient.take)(data, {
    roleCredentials: _smithyClient._json
  });
  Object.assign(contents, doc);
  return contents;
};
exports.de_GetRoleCredentialsCommand = de_GetRoleCredentialsCommand;
const de_GetRoleCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
const de_ListAccountRolesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_ListAccountRolesCommandError(output, context);
  }
  const contents = (0, _smithyClient.map)({
    $metadata: deserializeMetadata(output)
  });
  const data = (0, _smithyClient.expectNonNull)((0, _smithyClient.expectObject)(await parseBody(output.body, context)), "body");
  const doc = (0, _smithyClient.take)(data, {
    nextToken: _smithyClient.expectString,
    roleList: _smithyClient._json
  });
  Object.assign(contents, doc);
  return contents;
};
exports.de_ListAccountRolesCommand = de_ListAccountRolesCommand;
const de_ListAccountRolesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
const de_ListAccountsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_ListAccountsCommandError(output, context);
  }
  const contents = (0, _smithyClient.map)({
    $metadata: deserializeMetadata(output)
  });
  const data = (0, _smithyClient.expectNonNull)((0, _smithyClient.expectObject)(await parseBody(output.body, context)), "body");
  const doc = (0, _smithyClient.take)(data, {
    accountList: _smithyClient._json,
    nextToken: _smithyClient.expectString
  });
  Object.assign(contents, doc);
  return contents;
};
exports.de_ListAccountsCommand = de_ListAccountsCommand;
const de_ListAccountsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
const de_LogoutCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_LogoutCommandError(output, context);
  }
  const contents = (0, _smithyClient.map)({
    $metadata: deserializeMetadata(output)
  });
  await (0, _smithyClient.collectBody)(output.body, context);
  return contents;
};
exports.de_LogoutCommand = de_LogoutCommand;
const de_LogoutCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
const throwDefaultError = (0, _smithyClient.withBaseException)(_SSOServiceException.SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
  const contents = (0, _smithyClient.map)({});
  const data = parsedOutput.body;
  const doc = (0, _smithyClient.take)(data, {
    message: _smithyClient.expectString
  });
  Object.assign(contents, doc);
  const exception = new _models_.InvalidRequestException({
    $metadata: deserializeMetadata(parsedOutput),
    ...contents
  });
  return (0, _smithyClient.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const contents = (0, _smithyClient.map)({});
  const data = parsedOutput.body;
  const doc = (0, _smithyClient.take)(data, {
    message: _smithyClient.expectString
  });
  Object.assign(contents, doc);
  const exception = new _models_.ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...contents
  });
  return (0, _smithyClient.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
  const contents = (0, _smithyClient.map)({});
  const data = parsedOutput.body;
  const doc = (0, _smithyClient.take)(data, {
    message: _smithyClient.expectString
  });
  Object.assign(contents, doc);
  const exception = new _models_.TooManyRequestsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...contents
  });
  return (0, _smithyClient.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
  const contents = (0, _smithyClient.map)({});
  const data = parsedOutput.body;
  const doc = (0, _smithyClient.take)(data, {
    message: _smithyClient.expectString
  });
  Object.assign(contents, doc);
  const exception = new _models_.UnauthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...contents
  });
  return (0, _smithyClient.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = output => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
const collectBodyString = (streamBody, context) => (0, _smithyClient.collectBody)(streamBody, context).then(body => context.utf8Encoder(body));
const isSerializableHeaderValue = value => value !== undefined && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then(encoded => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
const parseErrorBody = async (errorBody, context) => {
  const value = await parseBody(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
const loadRestJsonErrorCode = (output, data) => {
  const findKey = (object, key) => Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = rawValue => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }
};